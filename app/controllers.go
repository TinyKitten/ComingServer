// Code generated by goagen v1.3.1, DO NOT EDIT.
//
// API "ComingServer": Application Controllers
//
// Command:
// $ goagen
// --design=github.com/TinyKitten/ComingServer/design
// --out=$(GOPATH)/src/github.com/TinyKitten/ComingServer
// --version=v1.3.1

package app

import (
	"context"
	"github.com/goadesign/goa"
	"github.com/goadesign/goa/cors"
	"net/http"
)

// initService sets up the service encoders, decoders and mux.
func initService(service *goa.Service) {
	// Setup encoders and decoders
	service.Encoder.Register(goa.NewJSONEncoder, "application/json")
	service.Encoder.Register(goa.NewGobEncoder, "application/gob", "application/x-gob")
	service.Encoder.Register(goa.NewXMLEncoder, "application/xml")
	service.Decoder.Register(goa.NewJSONDecoder, "application/json")
	service.Decoder.Register(goa.NewGobDecoder, "application/gob", "application/x-gob")
	service.Decoder.Register(goa.NewXMLDecoder, "application/xml")

	// Setup default encoder and decoder
	service.Encoder.Register(goa.NewJSONEncoder, "*/*")
	service.Decoder.Register(goa.NewJSONDecoder, "*/*")
}

// AuthController is the controller interface for the Auth actions.
type AuthController interface {
	goa.Muxer
	Auth(*AuthAuthContext) error
}

// MountAuthController "mounts" a Auth resource controller on the given service.
func MountAuthController(service *goa.Service, ctrl AuthController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/v1/auth", ctrl.MuxHandler("preflight", handleAuthOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAuthAuthContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AuthAuthPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Auth(rctx)
	}
	h = handleAuthOrigin(h)
	service.Mux.Handle("POST", "/v1/auth", ctrl.MuxHandler("auth", h, unmarshalAuthAuthPayload))
	service.LogInfo("mount", "ctrl", "Auth", "action", "Auth", "route", "POST /v1/auth")
}

// handleAuthOrigin applies the CORS response headers corresponding to the origin.
func handleAuthOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "Authorization, Origin, X-Requested-With, Content-Type, Accept")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAuthAuthPayload unmarshals the request body into the context request data Payload field.
func unmarshalAuthAuthPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &authAuthPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// PeersController is the controller interface for the Peers actions.
type PeersController interface {
	goa.Muxer
	Add(*AddPeersContext) error
	CurrentLocation(*CurrentLocationPeersContext) error
	List(*ListPeersContext) error
	Locations(*LocationsPeersContext) error
	RegenerateToken(*RegenerateTokenPeersContext) error
	SendLocation(*SendLocationPeersContext) error
	Show(*ShowPeersContext) error
	Update(*UpdatePeersContext) error
}

// MountPeersController "mounts" a Peers resource controller on the given service.
func MountPeersController(service *goa.Service, ctrl PeersController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/v1/peers", ctrl.MuxHandler("preflight", handlePeersOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/peers/:id/location", ctrl.MuxHandler("preflight", handlePeersOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/peers/:id/locations", ctrl.MuxHandler("preflight", handlePeersOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/peers/:id/token", ctrl.MuxHandler("preflight", handlePeersOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/peers/:id", ctrl.MuxHandler("preflight", handlePeersOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AddPeersPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Add(rctx)
	}
	h = handleSecurity("jwt", h, "api:write")
	h = handlePeersOrigin(h)
	service.Mux.Handle("POST", "/v1/peers", ctrl.MuxHandler("add", h, unmarshalAddPeersPayload))
	service.LogInfo("mount", "ctrl", "Peers", "action", "Add", "route", "POST /v1/peers", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewCurrentLocationPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.CurrentLocation(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePeersOrigin(h)
	service.Mux.Handle("GET", "/v1/peers/:id/location", ctrl.MuxHandler("current location", h, nil))
	service.LogInfo("mount", "ctrl", "Peers", "action", "CurrentLocation", "route", "GET /v1/peers/:id/location", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewListPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.List(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePeersOrigin(h)
	service.Mux.Handle("GET", "/v1/peers", ctrl.MuxHandler("list", h, nil))
	service.LogInfo("mount", "ctrl", "Peers", "action", "List", "route", "GET /v1/peers", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewLocationsPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Locations(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePeersOrigin(h)
	service.Mux.Handle("GET", "/v1/peers/:id/locations", ctrl.MuxHandler("locations", h, nil))
	service.LogInfo("mount", "ctrl", "Peers", "action", "Locations", "route", "GET /v1/peers/:id/locations", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegenerateTokenPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegenerateToken(rctx)
	}
	h = handleSecurity("jwt", h, "api:write")
	h = handlePeersOrigin(h)
	service.Mux.Handle("PATCH", "/v1/peers/:id/token", ctrl.MuxHandler("regenerate token", h, nil))
	service.LogInfo("mount", "ctrl", "Peers", "action", "RegenerateToken", "route", "PATCH /v1/peers/:id/token", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSendLocationPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*SendLocationPeersPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.SendLocation(rctx)
	}
	h = handleSecurity("optional_jwt", h, "api:admin")
	h = handlePeersOrigin(h)
	service.Mux.Handle("POST", "/v1/peers/:id/locations", ctrl.MuxHandler("send location", h, unmarshalSendLocationPeersPayload))
	service.LogInfo("mount", "ctrl", "Peers", "action", "SendLocation", "route", "POST /v1/peers/:id/locations", "security", "optional_jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowPeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePeersOrigin(h)
	service.Mux.Handle("GET", "/v1/peers/:id", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Peers", "action", "Show", "route", "GET /v1/peers/:id", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUpdatePeersContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UpdatePeersPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Update(rctx)
	}
	h = handleSecurity("jwt", h, "api:write")
	h = handlePeersOrigin(h)
	service.Mux.Handle("PUT", "/v1/peers/:id", ctrl.MuxHandler("update", h, unmarshalUpdatePeersPayload))
	service.LogInfo("mount", "ctrl", "Peers", "action", "Update", "route", "PUT /v1/peers/:id", "security", "jwt")
}

// handlePeersOrigin applies the CORS response headers corresponding to the origin.
func handlePeersOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "Authorization, Origin, X-Requested-With, Content-Type, Accept")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddPeersPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddPeersPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &addPeersPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalSendLocationPeersPayload unmarshals the request body into the context request data Payload field.
func unmarshalSendLocationPeersPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &sendLocationPeersPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalUpdatePeersPayload unmarshals the request body into the context request data Payload field.
func unmarshalUpdatePeersPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &updatePeersPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// PodsController is the controller interface for the Pods actions.
type PodsController interface {
	goa.Muxer
	Add(*AddPodsContext) error
	List(*ListPodsContext) error
	PeersList(*PeersListPodsContext) error
	RegenerateToken(*RegenerateTokenPodsContext) error
	Show(*ShowPodsContext) error
	Update(*UpdatePodsContext) error
}

// MountPodsController "mounts" a Pods resource controller on the given service.
func MountPodsController(service *goa.Service, ctrl PodsController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/v1/pods", ctrl.MuxHandler("preflight", handlePodsOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/pods/:id/peers", ctrl.MuxHandler("preflight", handlePodsOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/pods/:id/token", ctrl.MuxHandler("preflight", handlePodsOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/pods/:id", ctrl.MuxHandler("preflight", handlePodsOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddPodsContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AddPodsPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Add(rctx)
	}
	h = handleSecurity("jwt", h, "api:write")
	h = handlePodsOrigin(h)
	service.Mux.Handle("POST", "/v1/pods", ctrl.MuxHandler("add", h, unmarshalAddPodsPayload))
	service.LogInfo("mount", "ctrl", "Pods", "action", "Add", "route", "POST /v1/pods", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewListPodsContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.List(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePodsOrigin(h)
	service.Mux.Handle("GET", "/v1/pods", ctrl.MuxHandler("list", h, nil))
	service.LogInfo("mount", "ctrl", "Pods", "action", "List", "route", "GET /v1/pods", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewPeersListPodsContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.PeersList(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePodsOrigin(h)
	service.Mux.Handle("GET", "/v1/pods/:id/peers", ctrl.MuxHandler("peers list", h, nil))
	service.LogInfo("mount", "ctrl", "Pods", "action", "PeersList", "route", "GET /v1/pods/:id/peers", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewRegenerateTokenPodsContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.RegenerateToken(rctx)
	}
	h = handleSecurity("jwt", h, "api:write")
	h = handlePodsOrigin(h)
	service.Mux.Handle("POST", "/v1/pods/:id/token", ctrl.MuxHandler("regenerate token", h, nil))
	service.LogInfo("mount", "ctrl", "Pods", "action", "RegenerateToken", "route", "POST /v1/pods/:id/token", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowPodsContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("jwt", h, "api:read")
	h = handlePodsOrigin(h)
	service.Mux.Handle("GET", "/v1/pods/:id", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Pods", "action", "Show", "route", "GET /v1/pods/:id", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewUpdatePodsContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*UpdatePodsPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Update(rctx)
	}
	h = handleSecurity("jwt", h, "api:write")
	h = handlePodsOrigin(h)
	service.Mux.Handle("PUT", "/v1/pods/:id", ctrl.MuxHandler("update", h, unmarshalUpdatePodsPayload))
	service.LogInfo("mount", "ctrl", "Pods", "action", "Update", "route", "PUT /v1/pods/:id", "security", "jwt")
}

// handlePodsOrigin applies the CORS response headers corresponding to the origin.
func handlePodsOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "Authorization, Origin, X-Requested-With, Content-Type, Accept")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddPodsPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddPodsPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &addPodsPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// unmarshalUpdatePodsPayload unmarshals the request body into the context request data Payload field.
func unmarshalUpdatePodsPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &updatePodsPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// SwaggerController is the controller interface for the Swagger actions.
type SwaggerController interface {
	goa.Muxer
	goa.FileServer
}

// MountSwaggerController "mounts" a Swagger resource controller on the given service.
func MountSwaggerController(service *goa.Service, ctrl SwaggerController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/swagger.json", ctrl.MuxHandler("preflight", handleSwaggerOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/swaggerui/*filepath", ctrl.MuxHandler("preflight", handleSwaggerOrigin(cors.HandlePreflight()), nil))

	h = ctrl.FileHandler("/swagger.json", "swagger/swagger.json")
	h = handleSwaggerOrigin(h)
	service.Mux.Handle("GET", "/swagger.json", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Swagger", "files", "swagger/swagger.json", "route", "GET /swagger.json")

	h = ctrl.FileHandler("/swaggerui/*filepath", "swaggerui/dist")
	h = handleSwaggerOrigin(h)
	service.Mux.Handle("GET", "/swaggerui/*filepath", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Swagger", "files", "swaggerui/dist", "route", "GET /swaggerui/*filepath")

	h = ctrl.FileHandler("/swaggerui/", "swaggerui/dist/index.html")
	h = handleSwaggerOrigin(h)
	service.Mux.Handle("GET", "/swaggerui/", ctrl.MuxHandler("serve", h, nil))
	service.LogInfo("mount", "ctrl", "Swagger", "files", "swaggerui/dist/index.html", "route", "GET /swaggerui/")
}

// handleSwaggerOrigin applies the CORS response headers corresponding to the origin.
func handleSwaggerOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// UsersController is the controller interface for the Users actions.
type UsersController interface {
	goa.Muxer
	Add(*AddUsersContext) error
	List(*ListUsersContext) error
	Show(*ShowUsersContext) error
}

// MountUsersController "mounts" a Users resource controller on the given service.
func MountUsersController(service *goa.Service, ctrl UsersController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/v1/users", ctrl.MuxHandler("preflight", handleUsersOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/users/:id", ctrl.MuxHandler("preflight", handleUsersOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewAddUsersContext(ctx, req, service)
		if err != nil {
			return err
		}
		// Build the payload
		if rawPayload := goa.ContextRequest(ctx).Payload; rawPayload != nil {
			rctx.Payload = rawPayload.(*AddUsersPayload)
		} else {
			return goa.MissingPayloadError()
		}
		return ctrl.Add(rctx)
	}
	h = handleSecurity("jwt", h, "api:admin")
	h = handleUsersOrigin(h)
	service.Mux.Handle("POST", "/v1/users", ctrl.MuxHandler("add", h, unmarshalAddUsersPayload))
	service.LogInfo("mount", "ctrl", "Users", "action", "Add", "route", "POST /v1/users", "security", "jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewListUsersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.List(rctx)
	}
	h = handleSecurity("optional_jwt", h, "api:read")
	h = handleUsersOrigin(h)
	service.Mux.Handle("GET", "/v1/users", ctrl.MuxHandler("list", h, nil))
	service.LogInfo("mount", "ctrl", "Users", "action", "List", "route", "GET /v1/users", "security", "optional_jwt")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewShowUsersContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.Show(rctx)
	}
	h = handleSecurity("optional_jwt", h, "api:read")
	h = handleUsersOrigin(h)
	service.Mux.Handle("GET", "/v1/users/:id", ctrl.MuxHandler("show", h, nil))
	service.LogInfo("mount", "ctrl", "Users", "action", "Show", "route", "GET /v1/users/:id", "security", "optional_jwt")
}

// handleUsersOrigin applies the CORS response headers corresponding to the origin.
func handleUsersOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "Authorization, Origin, X-Requested-With, Content-Type, Accept")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}

// unmarshalAddUsersPayload unmarshals the request body into the context request data Payload field.
func unmarshalAddUsersPayload(ctx context.Context, service *goa.Service, req *http.Request) error {
	payload := &addUsersPayload{}
	if err := service.DecodeRequest(req, payload); err != nil {
		return err
	}
	payload.Finalize()
	if err := payload.Validate(); err != nil {
		// Initialize payload with private data structure so it can be logged
		goa.ContextRequest(ctx).Payload = payload
		return err
	}
	goa.ContextRequest(ctx).Payload = payload.Publicize()
	return nil
}

// WebsocketController is the controller interface for the Websocket actions.
type WebsocketController interface {
	goa.Muxer
	ReceivePeerLocation(*ReceivePeerLocationWebsocketContext) error
	SendCurrentPeerLocation(*SendCurrentPeerLocationWebsocketContext) error
}

// MountWebsocketController "mounts" a Websocket resource controller on the given service.
func MountWebsocketController(service *goa.Service, ctrl WebsocketController) {
	initService(service)
	var h goa.Handler
	service.Mux.Handle("OPTIONS", "/v1/pod", ctrl.MuxHandler("preflight", handleWebsocketOrigin(cors.HandlePreflight()), nil))
	service.Mux.Handle("OPTIONS", "/v1/peer", ctrl.MuxHandler("preflight", handleWebsocketOrigin(cors.HandlePreflight()), nil))

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewReceivePeerLocationWebsocketContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.ReceivePeerLocation(rctx)
	}
	h = handleWebsocketOrigin(h)
	service.Mux.Handle("GET", "/v1/pod", ctrl.MuxHandler("receive peer location", h, nil))
	service.LogInfo("mount", "ctrl", "Websocket", "action", "ReceivePeerLocation", "route", "GET /v1/pod")

	h = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		// Check if there was an error loading the request
		if err := goa.ContextError(ctx); err != nil {
			return err
		}
		// Build the context
		rctx, err := NewSendCurrentPeerLocationWebsocketContext(ctx, req, service)
		if err != nil {
			return err
		}
		return ctrl.SendCurrentPeerLocation(rctx)
	}
	h = handleWebsocketOrigin(h)
	service.Mux.Handle("GET", "/v1/peer", ctrl.MuxHandler("send current peer location", h, nil))
	service.LogInfo("mount", "ctrl", "Websocket", "action", "SendCurrentPeerLocation", "route", "GET /v1/peer")
}

// handleWebsocketOrigin applies the CORS response headers corresponding to the origin.
func handleWebsocketOrigin(h goa.Handler) goa.Handler {

	return func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {
		origin := req.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			return h(ctx, rw, req)
		}
		if cors.MatchOrigin(origin, "*") {
			ctx = goa.WithLogContext(ctx, "origin", origin)
			rw.Header().Set("Access-Control-Allow-Origin", origin)
			rw.Header().Set("Access-Control-Expose-Headers", "X-Time")
			rw.Header().Set("Access-Control-Max-Age", "600")
			rw.Header().Set("Access-Control-Allow-Credentials", "true")
			if acrm := req.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				rw.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
				rw.Header().Set("Access-Control-Allow-Headers", "Authorization, Origin, X-Requested-With, Content-Type, Accept")
			}
			return h(ctx, rw, req)
		}

		return h(ctx, rw, req)
	}
}
